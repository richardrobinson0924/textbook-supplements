\documentclass[letterpaper, openany, justified]{tufte-book}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{empheq}
\usepackage[dvipsnames]{xcolor}
\usepackage{multicol}

\setlength{\parindent}{0pt}
\title{Java Language, II}
\author{Richard Robinson}

\newcommand{\cd}[1]{\lstinline{#1}}
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{ppurple}{rgb}{0.6,0,0.35}
\definecolor{pblue2}{RGB}{65,158,242}
\definecolor{ppurple2}{RGB}{197,83,220}

\lstset{language=java}
\lstset{%
  aboveskip=3mm,
  belowskip=3mm,
  basicstyle={\small\ttfamily},
  captionpos=none,
  keywordstyle=\bfseries\color{ppurple2},
  commentstyle=\itshape\color{pgreen},
  stringstyle=\color{pblue2},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  morekeywords={String, type, access, obj}
}

\begin{document}
\maketitle
\tableofcontents
\setlength{\parindent}{0pt}
\begin{fullwidth}

\chapter{Introduction}

\section{JavaDoc \& Generics}

Utility and other classes may have internal and/or external documentation. The former appears via standard comments (that is, \cd{//} or \cd{/* */}) and explains the specifics of the class. Consequently, the external documentation known as the \emph{API} explains the class' usage via \cd{/** */} and is formatted in HTML. They are placed before public attributes, constructors, methods, and the classes themselves.

\bigskip
There are also special tags for API comments such as \cd{@param} which documents the method parameters, and \cd{@return} which documents what the method returns. In addition, the \cd{@pre} tag specifies the conditions and \cd{@throws} specifies possible exceptions. The API may be extracted in command line via
\begin{lstlisting}
    javadoc -d directoryname ClassName.java
\end{lstlisting}
Generally, avoiding overloading is best, which may be achieved by using the most general interface possible to declare parameters. Additionally, the generic type \cd{T} allows for any type to be used in a method. To restrict the generic type \cd{T} such that it must implement a specific interface, the syntax
\begin{lstlisting}
    access static <T> type methodName
        (Object<? extends InterfaceName<? super T>> rstArg, T nonrstArgs...) { }
\end{lstlisting}
wherein \cd{?} is a \emph{wildcard}, meaning \cd{? super T} is matched by \cd{T} or \cd{super(T)}, and the code within the outer angle brackets can be considered a restricted generic type itself. Finally, the \cd{@assert} tag ensures that even non-standard conditions are taken care of.

\section{Terminology}



\chapter{Classes}

\section{Static Classes}
A Java class has attributes, constructors, and methods, and typically instantiated by using the \cd{new} keyword to invoke a constructor. A class wherein its objects are stateless or have the same attribute values is called a \emph{utility class}. These classes need not be instantiated and are prefixed with \cd{static}.

\bigskip
Classes that have no or single-state attributes are typically utility classes, and only uses the arguments passed to it and not on any other parameters. A UML diagram of a utility class has the format:
\begin{lstlisting}
    <<utility>>
    java::packageName::className
    + publicAtt : type
    + publicMethod1(arg types) : type
\end{lstlisting}
The general form of the implementation of a utility class in Java is given by the syntax
\begin{lstlisting}
    public class UtilName {
        access static final type attribute = value; // attributes
        private UtilName(){} // empty constructor
        access static type methodName(type args) {
            // method code
            return methodName
        }
        access static void methodName{obj args} {
            args.objMethod; // mutator
        }
    }
\end{lstlisting}
wherein \cd{access} is one of \cd{public, private}. All non-final attributes should be private. The \cd{final} keyword in itself is optional, and used if the attribute is a constant. In utility classes, the entire class is within the attribute's scope. Such a class may be tested in \cd{main} by testing it for a variety of random arguments.

\bigskip
To avoid confusion between identical parameter and attribute names, the syntax \cd{ClassName.name} to refer to the attribute and \cd{name} for the parameter. \emph{Overloading} of a method occurs if there are multiple methods with the same name but different parameter types. For arguments that do not meet a specific condition, a method may throw a new exception via the syntax
\begin{lstlisting}
    access static type methodName(type args) throws IllegalArgumentException {
        if (condition) throw new IllegalArgumentException("Error Message");
        // method code
        return methodName;
    }
\end{lstlisting}

\section{Non-Static Classes}
This chapter focuses on classes entirely with non-static features. In the case of these classes, the client must first create an instance of it; that is, an object with the syntax
\begin{lstlisting}
    ClassName name = new ClassName(); // creates new object using default constructor
    ClassName newName = new ClassName(args) // new object with arguments
    newName.methodName(args); // mutator
\end{lstlisting}
The UML diagram for a non-static class is as follows:
\begin{lstlisting}
    ClassName
    + methodName(optionalArgs) : type
\end{lstlisting}
Additionally, the syntax itself for the definition of a non-static class with multiple types of constructors is given by
\lstset{frame = single}
\begin{lstlisting}
    public class ClassName extends OptParent implements OptInterface {
        access type field; // attributes

        // constructors
        public ClassName() { this(defaultValue); }
        public ClassName(type field) { this.setField(field) }

        // methods
        public type getField() { return this.field; }
        public void setField(type field) { this.field = field; }

        // obligatory methods
        public String toString() { return "str"; }
        public boolean equals(ClassName obj) { return this.field == obj.field; }
        public int hashCode() { return this.getFieldi() }
    }
\end{lstlisting}
When possible, the attributes should be of access \cd{private} as it prevents possible mistakes, nor should they be initialized. Importantly, the \cd{this.var} keyword always references the attribute variable, not the parameter one, as is similar to the \cd{ClassName.var} syntax for static classes so as to disambiguate between variables of the same name.

\section{Static vs Non-Static}
Here is an example of the same class using static and non-static properties:
\begin{multicols}{2}
\begin{lstlisting}
    class Math {
        public static int sum = 0;
        private Math(){}
        public static double Avg(int... nums) {
            for (int i : nums) Math.sum += i;
            return Math.sum/nums.length
        }
    }


    class Main {
        public static void main(String[] args) {
            double hyp;
            hype = ExtendedMath.Avg(1,3,5);
        }
    }
\end{lstlisting}

\columnbreak
\begin{lstlisting}
    class Math {
        private int[] nums;
        Math(int... nums) {this.nums = nums;}
        public double Avg() {
            int sum = 0;
            for (int i : this.nums) sum += i;
            return sum/this.nums.length
        }
    }

    class Main {
        public static void main(String[] args) {
            NumSet nums = new NumSet(1,3,5);
            nums.Avg();
        }
    }
\end{lstlisting}
\end{multicols}

\end{fullwidth}
\end{document}
