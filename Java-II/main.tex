\documentclass[letterpaper, openany, justified]{tufte-book}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{empheq}
\usepackage[dvipsnames]{xcolor}

\setlength{\parindent}{0pt}
\title{Java Language, II}
\author{Richard Robinson}

\newcommand{\cd}[1]{\lstinline{#1}}
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{ppurple}{rgb}{0.6,0,0.35}

\lstset{language=java}
\lstset{%
  aboveskip=3mm,
  belowskip=3mm,
  basicstyle={\small\ttfamily},
  captionpos=none,
  keywordstyle=\bfseries\color{magenta},
  commentstyle=\itshape\color{pgreen},
  stringstyle=\color{pred},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  morekeywords={String, type, access, obj}
}

\begin{document}
\maketitle
\tableofcontents
\setlength{\parindent}{0pt}
\begin{fullwidth}

\chapter{Introduction}

\section{Utility Classes}
A Java class has attributes, constructors, and methods, and typically instantiated by using the \cd{new} keyword to invoke a constructor. A class wherein its objects are stateless or have the same attribute values is called a \emph{utility class}. These classes need not be instantiated and are prefixed with \cd{static}. For example, the \cd{Math} utility class methods can simply be used via \cd{Math.methodName}.

\bigskip
Classes that have no or single-state attributes are typically utility classes, and only uses the arguments passed to it and not on any other parameters. A UML diagram of a utility class has the format:
\begin{lstlisting}
    <<utility>>
    java::packageName::className
    + publicAtt : type
    + publicMethod1(arg types) : type
\end{lstlisting}
The general form of the implementation of a utility class in Java is given by the syntax
\begin{lstlisting}
    public class UtilName {
        access static final type attribute = value; // attributes
        private UtilName(){} // empty constructor
        access static type methodName(type args) {
            // method code
            return methodName
        }
        access static void methodName{obj args} {
            args.objMethod; // mutator
        }
    }
\end{lstlisting}
wherein \cd{access} is one of \cd{public, private}. All non-final attributes should be private. The \cd{final} keyword in itself is optional, and used if the attribute is a constant. In utility classes, the entire class is within the attribute's scope. Such a class may be tested in \cd{main} by testing it for a variety of random arguments.

\section{Arguments \& Parameters}
Classes are know to be \emph{pass-by-value}; this means that upon calling a class' method, its arguments are created new from memory of the argument of the caller, instead of simply its memory location. The argument values do not change regardless of the method; however, properties of objects may be mutated.

\bigskip
\emph{Parameters} are the variable arguments in the method declaration header. These parameters are then initialized to the passed values of the arguments. For example, considering an object \cd{obj}, a method may be of the form:
\begin{lstlisting}
    public static void methodName(obj objName) {
        objName.setAtt(2 * objName.getAtt); // mutator: uses the setAtt and getAtt methods of obj
    }
\end{lstlisting}
To avoid confusion between identical parameter and attribute names, the syntax \cd{ClassName.name} to refer to the attribute and \cd{name} for the parameter. \emph{Overloading} of a method occurs if there are multiple methods with the same name but different parameter types. Note however a method of the form
\begin{lstlisting}
    static void methodName(type arg) { arg++; }
\end{lstlisting}
has no effect as it does not return a value (it is void) nor mutates an object. For arguments that do not meet a specific condition, a method may throw a new exception via the syntax
\begin{lstlisting}
    access static type methodName(type args) throws IllegalArgumentException {
        if (condition) throw new IllegalArgumentException("Error Message");
        // method code
        return methodName;
    }
\end{lstlisting}

\section{JavaDoc \& Generics}
Utility and other classes may have internal and/or external documentation. The former appears via standard comments (that is, \cd{//} or \cd{/* */}) and explains the specifics of the class. Consequently, the external documentation known as the \emph{API} explains the class' usage via \cd{/** */} and is formatted in HTML. They are placed before public attributes, constructors, methods, and the classes themselves.

\bigskip
There are also special tags for API comments such as \cd{@param} which documents the method parameters, and \cd{@return} which documents what the method returns. In addition, the \cd{@pre} tag specifies the conditions and \cd{@throws} specifies possible exceptions. The API may be extracted in command line via
\begin{lstlisting}
    javadox -d directorybame ClassName.java
\end{lstlisting}
Generally, avoiding overloading is best, which may be achieved by using the most general interface possible to declare parameters. Additionally, the generic type \cd{T} allows for any type to be used in a method. To restrict the generic type \cd{T} such that it must implement a specific interface, the syntax
\begin{lstlisting}
    access static <T> type methodName
        (Object<? extends InterfaceName<? super T>> rstArg, T nonrstArgs...) { }
\end{lstlisting}
wherein \cd{?} is a \emph{wildcard}, meaning \cd{? super T} is matched by \cd{T} or \cd{super(T)}, and the code within the outer angle brackets can be considered a restricted generic type itself.

\section{@Assert}


\end{fullwidth}
\end{document}
