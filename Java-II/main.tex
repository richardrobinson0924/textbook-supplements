\documentclass[letterpaper, openany, justified]{tufte-book}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{empheq}
\usepackage[dvipsnames]{xcolor}
\usepackage{multicol}

\setlength{\parindent}{0pt}
\title{Java Language, II}
\author{Richard Robinson}

\newcommand{\cd}[1]{\lstinline{#1}}
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{ppurple}{rgb}{0.6,0,0.35}
\definecolor{pblue2}{RGB}{65,158,242}
\definecolor{ppurple2}{RGB}{197,83,220}

\lstset{language=java}
\lstset{%
  aboveskip=3mm,
  belowskip=3mm,
  basicstyle={\small\ttfamily},
  captionpos=none,
  keywordstyle=\bfseries\color{ppurple2},
  commentstyle=\itshape\color{pgreen},
  stringstyle=\color{pblue2},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  morekeywords={String, type, access, obj}
}

\begin{document}
\maketitle
\tableofcontents
\setlength{\parindent}{0pt}
\begin{fullwidth}

\chapter{Introduction}

\section{Utility Classes}
A Java class has attributes, constructors, and methods, and typically instantiated by using the \cd{new} keyword to invoke a constructor. A class wherein its objects are stateless or have the same attribute values is called a \emph{utility class}. These classes need not be instantiated and are prefixed with \cd{static}. For example, the \cd{Math} utility class methods can simply be used via \cd{Math.methodName}.

\bigskip
Classes that have no or single-state attributes are typically utility classes, and only uses the arguments passed to it and not on any other parameters. A UML diagram of a utility class has the format:
\begin{lstlisting}
    <<utility>>
    java::packageName::className
    + publicAtt : type
    + publicMethod1(arg types) : type
\end{lstlisting}
The general form of the implementation of a utility class in Java is given by the syntax
\begin{lstlisting}
    public class UtilName {
        access static final type attribute = value; // attributes
        private UtilName(){} // empty constructor
        access static type methodName(type args) {
            // method code
            return methodName
        }
        access static void methodName{obj args} {
            args.objMethod; // mutator
        }
    }
\end{lstlisting}
wherein \cd{access} is one of \cd{public, private}. All non-final attributes should be private. The \cd{final} keyword in itself is optional, and used if the attribute is a constant. In utility classes, the entire class is within the attribute's scope. Such a class may be tested in \cd{main} by testing it for a variety of random arguments.

\section{Arguments \& Parameters}
Classes are know to be \emph{pass-by-value}; this means that upon calling a class' method, its arguments are created new from memory of the argument of the caller, instead of simply its memory location. The argument values do not change regardless of the method; however, properties of objects may be mutated.

\bigskip
\emph{Parameters} are the variable arguments in the method declaration header. These parameters are then initialized to the passed values of the arguments. For example, considering an object \cd{obj}, a method may be of the form:
\begin{lstlisting}
    public static void methodName(obj objName) {
        objName.setAtt(2 * objName.getAtt); // mutator: uses the setAtt and getAtt methods of obj
    }
\end{lstlisting}
To avoid confusion between identical parameter and attribute names, the syntax \cd{ClassName.name} to refer to the attribute and \cd{name} for the parameter. \emph{Overloading} of a method occurs if there are multiple methods with the same name but different parameter types. Note however a method of the form
\begin{lstlisting}
    static void methodName(type arg) { arg++; }
\end{lstlisting}
has no effect as it does not return a value (it is void) nor mutates an object. For arguments that do not meet a specific condition, a method may throw a new exception via the syntax
\begin{lstlisting}
    access static type methodName(type args) throws IllegalArgumentException {
        if (condition) throw new IllegalArgumentException("Error Message");
        // method code
        return methodName;
    }
\end{lstlisting}

\section{JavaDoc \& Generics}
Utility and other classes may have internal and/or external documentation. The former appears via standard comments (that is, \cd{//} or \cd{/* */}) and explains the specifics of the class. Consequently, the external documentation known as the \emph{API} explains the class' usage via \cd{/** */} and is formatted in HTML. They are placed before public attributes, constructors, methods, and the classes themselves.

\bigskip
There are also special tags for API comments such as \cd{@param} which documents the method parameters, and \cd{@return} which documents what the method returns. In addition, the \cd{@pre} tag specifies the conditions and \cd{@throws} specifies possible exceptions. The API may be extracted in command line via
\begin{lstlisting}
    javadoc -d directoryname ClassName.java
\end{lstlisting}
Generally, avoiding overloading is best, which may be achieved by using the most general interface possible to declare parameters. Additionally, the generic type \cd{T} allows for any type to be used in a method. To restrict the generic type \cd{T} such that it must implement a specific interface, the syntax
\begin{lstlisting}
    access static <T> type methodName
        (Object<? extends InterfaceName<? super T>> rstArg, T nonrstArgs...) { }
\end{lstlisting}
wherein \cd{?} is a \emph{wildcard}, meaning \cd{? super T} is matched by \cd{T} or \cd{super(T)}, and the code within the outer angle brackets can be considered a restricted generic type itself. Finally, the \cd{@assert} tag ensures that even non-standard conditions are taken care of.

\chapter{Non-Static Classes}

\section{Class Structure}
This chapter focuses on classes entirely with non-static features. In the case of these classes, the client must first create an instance of it; that is, an object with the syntax
\begin{lstlisting}
    ClassName name = new ClassName(); // creates new object using default constructor
    ClassName newName = new ClassName(args) // new object with arguments
    newName.methodName(args); // mutator
\end{lstlisting}
The UML diagram for a non-static class is as follows:
\begin{lstlisting}
    ClassName
    + methodName(optionalArgs) : type
\end{lstlisting}
Additionally, the syntax itself for the definition of a non-static class with multiple types of constructors is given by
\begin{lstlisting}
    public class ClassName extends OptParent implements OptInterface {
        access type name; // attributes
        public ClassName() { this.field = defaultValue; } // default constructor
        public ClassName(type fields) { this.field = field; } // other constructors
        public ClassName(ClassName obj) { this.field = obj.getField(); } // copy constructor
        // some methods
    }
\end{lstlisting}
When possible, the attributes should be of access \cd{private} as it prevents possible mistakes, nor should they be initialized. Importantly, the \cd{this.var} keyword always references the attribute variable, not the parameter one, as is similar to the \cd{ClassName.var} syntax for static classes so as to disambiguate between variables of the same name.

\section{Methods}
There are several different types of standard method types, including
\begin{lstlisting}
    public type getField() { return this.field; } // accessor
    public void setField(type field) { this.field = field; } // mutator
    public String toString() { return "str"; } // print(ClassName)
\end{lstlisting}
For a default constructor without arguments that is essentially a special case of another constructor with multiple arguments, the former may be simplified such that if the latter is
\begin{lstlisting}
    public ClassName(type fields) { }
\end{lstlisting}
then the former may be simplified to
\begin{lstlisting}
    public ClassName() { this(defaultValues); } // option 1
\end{lstlisting}
which calls the multi-argument constructor wherein the arguments are the default values. As aforementioned, methods of static classes are called via
\begin{lstlisting}
    ClassName.methodName(args);
\end{lstlisting}
whereas non-static classes must be initialized and then called via
\begin{lstlisting}
    ClassName name = new ClassName(args);
    name.methodName(args);
\end{lstlisting}

\section{Mutators \& Accessors}
Let there be the following constructor:
\begin{lstlisting}
    public ClassName(type field) {this.field = field;}
\end{lstlisting}
This constructor is inefficient, as it duplicates the code of the mutators. A better version is:
\begin{lstlisting}
    public ClassName(type field) {this.setField(field);}
\end{lstlisting}
Additionally, an accessor method of the following form is also inefficient, as it is vulnerable to changes in attributes:
\begin{lstlisting}
    public type getProperty() {return this.field; }
    public type getProperty() {return this.getField();} // better version
\end{lstlisting}
Note that \cd{String} objects are immutable, meaning they cannot be changed. This means assignment operators implicitly creates a new object in place of the old one. Immutability also makes it more efficient to use more restrictive access options wherever possible. For a \cd{Get} method such as the following, an appropriate \cd{Set} method should be written;
\begin{lstlisting}
    public type getComp() {return this.comp;}
    private void setComp() {this.comp = comp;}
\end{lstlisting}
which then must be called in each mutator method of the class. Lastly, class invariants with the \cd{@invariant} tag are properties of attributes which should never occur, such as negative properties.

\section{HashCode}
Like \cd{toString()}, the \cd{hashCode} method is another obligatory method from the \cd{Object} class.

\section{Static vs Non-Static}
Here is an example of the same class using static and non-static properties:
\setlength{\columnseprule}{0.4pt}
\begin{multicols}{2}
\begin{lstlisting}
    class ExtendedMath {
        public static int sum = 0;
        private ExtendedMath(){}
        public static double Avg(int... nums) {
            for (int i : nums) this.sum += i;
            return this.sum/nums.length
        }
    }


    class Main {
        public static void main(String[] args) {
            double hyp = ExtendedMath.Avg(1,3,5);
        }
    }
\end{lstlisting}

\columnbreak
\begin{lstlisting}
    class NumSet {
        private int[] nums;
        NumSet(int... nums) {this.nums = nums;}
        public double Avg() {
            int sum = 0;
            for (int i : this.nums) sum += i;
            return sum/this.nums.length
        }
    }

    class Main {
        public static void main(String[] args) {
            NumSet nums = new NumSet(1,3,5);
            nums.Avg();
        }
    }
\end{lstlisting}
\end{multicols}

\end{fullwidth}
\end{document}
